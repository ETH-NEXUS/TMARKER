/*
 * Copyright (C) 2015 peschuef
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package tmarker;

import TMARKERPluginInterface.Pluggable;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import tmarker.TMAspot.TMALabel;
import tmarker.TMAspot.TMApoint;
import tmarker.TMAspot.TMAspot;
import static tmarker.TMAspot_view_panel.drawAreas;
import static tmarker.TMAspot_view_panel.drawDensitySoft;
import tmarker.misc.Misc;
import tmarker.misc.SortedProperties;
import tmarker.misc.ZoomableNDPIPanel;
import static tmarker.TMA_view_panel.CURSOR_CROSS;
import static tmarker.TMA_view_panel.CURSOR_HAND;
import static tmarker.TMA_view_panel.RECENT_POLYLINE_X;
import static tmarker.TMA_view_panel.RECENT_POLYLINE_Y;
import static tmarker.TMAspot_view_panel.drawCellCounts;

/**
 *
 * @author Peter J. Schueffler
 */
public class WholeSlide_view_panel extends ZoomableNDPIPanel implements TMA_view_panel {
    
    tmarker t = null;
    TMAspot ts = null;
    Point MouseLocus = new Point(0,0);
    Polygon polygon_to_be_changed = null;
    int Image_Width = 0;
    int Image_Height = 0;

    public WholeSlide_view_panel(tmarker t) {
        initComponents();
        this.t = t;
        setZoomMin(0.001);
        setZoomMax(1.0);
        setMouseWheelEnabled(false);
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPopupMenu1 = new javax.swing.JPopupMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();

        jPopupMenu1.addPopupMenuListener(new javax.swing.event.PopupMenuListener() {
            public void popupMenuCanceled(javax.swing.event.PopupMenuEvent evt) {
            }
            public void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent evt) {
            }
            public void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent evt) {
                jPopupMenu1PopupMenuWillBecomeVisible(evt);
            }
        });

        jMenuItem1.setText("Delete Points in Area");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jPopupMenu1.add(jMenuItem1);

        jMenuItem2.setText("Copy ROI to Selected Images");
        jMenuItem2.setToolTipText("");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jPopupMenu1.add(jMenuItem2);

        addMouseWheelListener(new java.awt.event.MouseWheelListener() {
            public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
                formMouseWheelMoved(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
        });
        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        int image_x = (int) (evt.getX() / getZoom());
        int image_y = (int) (evt.getY() / getZoom());
        
        // if we are in background color correction modus, do this.
        if (t.isInBGCorrectionModus()) {
            t.performBGCorrection((int)(evt.getX()/getZoom()), (int)(evt.getY()/getZoom())); 
        } 
        // if we are in polygon drawing modus, do this.
        else if (evt.getClickCount() == 1 && (t.isInDrawIncludingAreaModus() || t.isInDrawExcludingAreaModus())) {
            
            // If there is a point to add at the outline, add it
            int w = TMAspot.POLYGON_NODE_WIDTH;
            Polygon pol = ts.getAreaOnPoint(image_x, image_y, w);
            if (pol!=null) {
                if (!pol.contains(image_x-w, image_y) || !pol.contains(image_x, image_y-w) 
                        || !pol.contains(image_x-w, image_y-w) || !pol.contains(image_x+w, image_y)
                        || !pol.contains(image_x, image_y+w) || !pol.contains(image_x+w, image_y+w)
                        || !pol.contains(image_x-w, image_y+w) || !pol.contains(image_x+w, image_y-w)) {
                    // decide where to add the new point (it can't simply be added as a new point, the order plays a role).
                    // That location is right, where the new point fits well into the first derivative of its neighbors (less than 10% deviance).
                    int i=0;
                    boolean locationFound = false;
                    for (i=0; i<pol.npoints; i++) {
                        double d_old = (1.0 * pol.xpoints[(i+1) % pol.npoints] - pol.xpoints[i]) / (1.0 * pol.ypoints[(i+1) % pol.npoints] - pol.ypoints[i]);
                        double d_new1 = (1.0 * image_x - pol.xpoints[i]) / (1.0 * image_y - pol.ypoints[i]);
                        double d_new2 = (1.0 * pol.xpoints[(i+1) % pol.npoints] - image_x) / (1.0 * pol.ypoints[(i+1) % pol.npoints] - image_y);
                        
                        if (d_old == 0) d_old = 0.000000001;
                        if (Double.isInfinite(d_old)) d_old = Double.MAX_VALUE;
                        if (Double.isInfinite(d_new1)) d_new1 = Double.MAX_VALUE;
                        if (Double.isInfinite(d_new2)) d_new2 = Double.MAX_VALUE;
                        
                        
                        if (Math.abs(Math.abs(d_old-d_new1)/d_old) <= 0.1 && Math.abs(Math.abs(d_old-d_new2)/d_old) <= 0.1) {
                            locationFound = true;
                            break;
                        }
                    }
                    if (locationFound) {
                        int[] xs = Arrays.copyOf(pol.xpoints, pol.npoints);
                        int[] ys = Arrays.copyOf(pol.ypoints, pol.npoints);
                        pol.reset();
                        int offset = 0;
                        for (int j=0; j<=xs.length; j++) {
                            if (j==i+1) {
                                pol.addPoint(image_x, image_y);
                                offset = 1;
                            } else {
                                pol.addPoint(xs[j-offset], ys[j-offset]);
                            }
                        }
                    }
                }
            } else {
                // else add a new point for a new drawn polygon
                RECENT_POLYLINE_X.add((int) (evt.getX() / getZoom()));
                RECENT_POLYLINE_Y.add((int) (evt.getY() / getZoom()));
            }
            repaint();
        } else if (evt.getClickCount() > 1 && (t.isInDrawIncludingAreaModus() || t.isInDrawExcludingAreaModus())) {
            // finalize and add the newly drawn polygon at double click.
            if (RECENT_POLYLINE_X.size()>2) {
                int[] xs = new int[RECENT_POLYLINE_X.size()];
                int[] ys = new int[RECENT_POLYLINE_Y.size()];
                for (int i = 0; i < RECENT_POLYLINE_X.size(); i++) {
                    xs[i] = RECENT_POLYLINE_X.get(i);
                    ys[i] = RECENT_POLYLINE_Y.get(i);
                }
                if (t.isInDrawIncludingAreaModus()) {
                    ts.getIncludingAreas().add(new Polygon(xs, ys, RECENT_POLYLINE_X.size()));
                } else {
                    ts.getExcludingAreas().add(new Polygon(xs, ys, RECENT_POLYLINE_X.size()));
                }
            }
            RECENT_POLYLINE_X.clear();
            RECENT_POLYLINE_Y.clear();
            repaint();
        }
        // on normal double click, increase zoom
        else if (evt.getClickCount() > 1 && !(t.isInDrawIncludingAreaModus() || t.isInDrawExcludingAreaModus())) {
            int amount = -3;
            Rectangle rect = getVisibleRect();
            double oldZoom = t.getZoom();
            if (amount <= 0) {
                t.setZoomSlider(Math.max((int) (100*getZoom()+1), (int) (100*getZoom() * getZoomFactor())));
            } else {
                t.setZoomSlider((int) (100*getZoom() / getZoomFactor()));
            }
            double newZoom = t.getZoom();
            double zfactor = newZoom / oldZoom;
            int dx = (int)((zfactor-1)*(evt.getX()));
            int dy = (int)((zfactor-1)*(evt.getY()));
            rect.translate(dx, dy);
            this.scrollRectToVisible(rect);
        }
        // if we are in polygon switching modus, do this.
        else if (t.isInSwitchAreaModus()) {
            ts.switchPolygonOnPoint((int)(evt.getPoint().x/getZoom()), (int)(evt.getPoint().y/getZoom()));
            repaint();
        } 
        // if we are in polygon deletion modus, do this.
        else if (t.isInDeleteAreaModus()) {
            ts.deletePolygonOnPoint((int)(evt.getPoint().x/getZoom()), (int)(evt.getPoint().y/getZoom()));
            repaint();
        } 
        // else...
        else {
            if(!evt.isControlDown()) {
                if (evt.getButton() == java.awt.event.MouseEvent.BUTTON1) { // the normal left button
                    Point p = new Point(evt.getPoint());
                    switch (t.getClickBehaviour()) {
                        case tmarker.CLICK_BEHAVIOUR_DELETE: { 
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                ts.removePoint(p_old);
                            } 
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_FLIP: {
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                if (t.getOptionDialog().isAutomaticESGSConversion()) {
                                    p_old.setGoldStandard(t.getGSNumberForLabeling());
                                }
                                p_old.flipLabel(false);
                            }
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_CORSTAIN_GRAD: {
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                if (t.getOptionDialog().isAutomaticESGSConversion()) {
                                    p_old.setGoldStandard(t.getGSNumberForLabeling());
                                }
                                p_old.flipStaining(false);
                            }
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_CORSTAIN_BIN: {
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                if (t.getOptionDialog().isAutomaticESGSConversion()) {
                                    p_old.setGoldStandard(t.getGSNumberForLabeling());
                                }
                                p_old.flipStaining(true);
                            }
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_ADD_POS: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_POS, ts.getCenter().getCurrentStainingIntensity());
                            } 
                            //tp.calculateStaining();
                            tp.setGoldStandard(t.getGSNumberForLabeling());
                            ts.addPoint(tp);
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_ADD_NEG: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_NEG, ts.getCenter().getCurrentStainingIntensity());
                            }
                            //tp.calculateStaining();
                            tp.setGoldStandard(t.getGSNumberForLabeling());
                            ts.addPoint(tp);
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_ADD_UNK: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_UNK, ts.getCenter().getCurrentStainingIntensity());
                            }
                            //tp.calculateStaining();
                            tp.setGoldStandard(t.getGSNumberForLabeling());
                            ts.addPoint(tp);
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_ADD_BG: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_BG);
                            }
                            //tp.calculateStaining();
                            tp.setGoldStandard(t.getGSNumberForLabeling());
                            ts.addPoint(tp);
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_NONE: {
                            break;
                        }
                        default: break;
                    }
                    repaint();
                    
                    ts.dispStainingInfo();
                }
            }
        }
        if (!t.getSelectedTMAspots(false).contains(ts)) {
            for (TMAspot ts_: t.getTMAspots()) {
                    ts_.setSelected(ts_==ts);
                }
        }
    }//GEN-LAST:event_formMouseClicked

    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        MouseLocus = evt.getPoint();
        
        int image_x = (int) (evt.getX() / getZoom());
        int image_y = (int) (evt.getY() / getZoom());
        int w = TMAspot.POLYGON_NODE_WIDTH;
        
        polygon_to_be_changed = ts.getAreaOnPoint(image_x, image_y, w); 
    }//GEN-LAST:event_formMousePressed

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        setCursor(CURSOR_CROSS);
        polygon_to_be_changed = null;
    }//GEN-LAST:event_formMouseReleased

    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        int image_x = (int) (evt.getX() / getZoom());
        int image_y = (int) (evt.getY() / getZoom());
        
        // if we are at a TMA point, drag it.
        TMApoint p_old = ts.getPointAt((int) (MouseLocus.getX() / getZoom()), (int) (MouseLocus.getY() / getZoom()), ts.getParam_r(), true);
        if (p_old != null) {
            p_old.x = image_x;
            p_old.y = image_y;
            if (t.getOptionDialog().isAutomaticESGSConversion()) {
                p_old.setGoldStandard(t.getGSNumberForLabeling());
            }
            MouseLocus = evt.getPoint();
            repaint();
            ts.dispStainingInfo();
            
            return;
        } 
        // if we are at a node of a newly drawn polygon, drag the node point.
        int w = TMAspot.POLYGON_NODE_WIDTH;
        if (!RECENT_POLYLINE_X.isEmpty()) {
            for (int i=0; i<RECENT_POLYLINE_X.size(); i++) {
                if (Math.abs(RECENT_POLYLINE_X.get(i)-(int) (MouseLocus.getX() / getZoom()))<=w/2 && Math.abs(RECENT_POLYLINE_Y.get(i)-(int) (MouseLocus.getY() / getZoom()))<=w/2) {
                    RECENT_POLYLINE_X.remove(i);
                    RECENT_POLYLINE_Y.remove(i);
                    RECENT_POLYLINE_X.add(i,image_x);
                    RECENT_POLYLINE_Y.add(i, image_y);
                    MouseLocus = evt.getPoint();
                    repaint();
                    return;
                }
            }
        }

        // if we are at a node of a polygon, drag the node.
        Polygon pol = polygon_to_be_changed; // it is assigned at mouseclick and relseased at mousereleased.
        if (pol != null) {
            for (int i=0; i<pol.npoints; i++) {
                if (Math.abs(pol.xpoints[i]-(int) (MouseLocus.getX() / getZoom()))<=w/2 && Math.abs(pol.ypoints[i]-(int) (MouseLocus.getY() / getZoom()))<=w/2) {
                    pol.xpoints[i] = image_x;
                    pol.ypoints[i] = image_y;
                    pol.invalidate();
                    MouseLocus = evt.getPoint();
                    repaint();
                    return;
                }
            }
        }
            setCursor(CURSOR_HAND);
            JScrollPane jsp = t.getTMAViewContainer();
            Point P = evt.getPoint();
            int dx = MouseLocus.x-P.x;
            int dy = MouseLocus.y-P.y;
            Rectangle r = jsp.getViewport().getVisibleRect();
            r.setLocation(r.x+dx, r.y+dy);
            jsp.getViewport().scrollRectToVisible(r);
    }//GEN-LAST:event_formMouseDragged

    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        try {
            int image_x = (int) (evt.getX() / getZoom());
            int image_y = (int) (evt.getY() / getZoom());
            
            t.setStatusMessageLabel("x = " + Integer.toString((int)(evt.getX()/getZoom())) + ", y = " + Integer.toString((int)(evt.getY()/getZoom())));
            t.showTMAspotLocalZoom((int)(evt.getX()/getZoom()), (int)(evt.getY()/getZoom()));
            t.showTMAspotLocalZoomOnPreview((int)(evt.getX()/getZoom()), (int)(evt.getY()/getZoom()));
            if (t.isInDrawIncludingAreaModus() || t.isInDrawExcludingAreaModus() || t.isInDeleteAreaModus()) {
                setCursor(CURSOR_CROSS);
                int w = TMAspot.POLYGON_NODE_WIDTH;
                
                // if we are at a node of a newly drawn polygon, show the curser to move it.
                if (!RECENT_POLYLINE_X.isEmpty()) {
                    for (int i=0; i<RECENT_POLYLINE_X.size(); i++) {
                        if (Math.abs(RECENT_POLYLINE_X.get(i)-image_x)<=w/2 && Math.abs(RECENT_POLYLINE_Y.get(i)-image_y)<=w/2) {
                            setCursor(CURSOR_MOVE);
                            break;
                        }
                    }
                }
                
                // if we are on a polygon node, show the cursor to move it.
                Polygon pol = ts.getAreaOnPoint(image_x, image_y, w);
                if (pol!=null) {
                    boolean nodeFound = false;
                    for (int i=0; i<pol.npoints; i++) {
                        if (Math.abs(pol.xpoints[i]-image_x)<=w/2 && Math.abs(pol.ypoints[i]-image_y)<=w/2) {
                            nodeFound = true;
                            setCursor(CURSOR_MOVE);
                            break;
                        }
                    }
                    // if we are at the border line of a polygon, show the "add a new polygon node" cursor.
                    if (!nodeFound && (!pol.contains(image_x-w, image_y) || !pol.contains(image_x, image_y-w) 
                            || !pol.contains(image_x-w, image_y-w) || !pol.contains(image_x+w, image_y)
                            || !pol.contains(image_x, image_y+w) || !pol.contains(image_x+w, image_y+w)
                            || !pol.contains(image_x-w, image_y+w) || !pol.contains(image_x+w, image_y-w))) {
                        setCursor(CURSOR_DEFAULT);
                    }
                }
                
                
            // if we are on a TMA point, show its summary in a tooltext.
            } else if (ts.hasStainingEstimation()) {
                TMApoint tp = ts.getPointAt((int)(evt.getX()/getZoom()), (int) (evt.getY()/getZoom()), ts.getParam_r(), true);
                if (tp!=null) {
                    setCursor(CURSOR_HAND);
                    String text = "<html><b>" + ts.getName() + "</b><br>"+
                            "TMA point (" + tp.x + ", " + tp.y + ")<br>";
                    text += "staining intensity: " + tp.getStaining() + "<br>";
                    text += tp.isGoldStandard() ? "is Gold Standard from labeler " + (tp.getGoldStandard()==TMApoint.CONSENSUS?"(consens)" : tp.getGoldStandard()) + "<br>" : "is computationally estimated<br>";
                    text += tp.isTrainingPoint(false) ? "was used for detection training <br>" : "";
                    text += tp.isTrainingPoint(true) ? "was used for classification training <br>" : "";
                    setToolTipText(text);
                } else {
                    setCursor(CURSOR_CROSS);
                    setToolTipText(null);
                }
            } else {
                setCursor(CURSOR_CROSS);
                setToolTipText(null);
            }
        } catch (Exception ex) {
            
        }
    }//GEN-LAST:event_formMouseMoved

    private void formMouseWheelMoved(java.awt.event.MouseWheelEvent evt) {//GEN-FIRST:event_formMouseWheelMoved
        int amount = evt.getWheelRotation();
        Rectangle rect = getVisibleRect();
        double oldZoom = t.getZoom();
        if (amount <= 0) {
            t.setZoomSlider(Math.max((int) (100*getZoom()+1), (int) (100*getZoom() * getZoomFactor())));
        } else {
            t.setZoomSlider((int) (100*getZoom() / getZoomFactor()));
        }
        double newZoom = t.getZoom();
        double zfactor = newZoom / oldZoom;
        int dx = (int)((zfactor-1)*(evt.getX()));
        int dy = (int)((zfactor-1)*(evt.getY()));
        rect.translate(dx, dy);
        this.scrollRectToVisible(rect);
    }//GEN-LAST:event_formMouseWheelMoved

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        Polygon pol = ts.getAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
        if (pol!=null) {
            ts.deletePointsInArea(pol);
            repaint();
        }
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        boolean including = true;
        Polygon pol = ts.getIncludingAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
        if (pol==null) {
            pol = ts.getExcludingAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
            including = false;
        }
        if (pol!=null) {
            List<TMAspot> tss = t.getSelectedTMAspots();
            for (TMAspot ts_: tss) {
                boolean addthispol = true;
                List<Polygon> areas_tmp = ts_.getExcludingAreas();
                areas_tmp.addAll(ts_.getIncludingAreas());
                for (Polygon p_tmp: areas_tmp) {
                    if (Misc.SamePolygons(p_tmp, pol)) {
                        addthispol = false;
                        break;
                    }
                }
                if (addthispol) {
                    if (including) ts_.getIncludingAreas().add(new Polygon(pol.xpoints, pol.ypoints, pol.npoints));
                    else ts_.getExcludingAreas().add(new Polygon(pol.xpoints, pol.ypoints, pol.npoints));
                }
            }
        }
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    private void jPopupMenu1PopupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent evt) {//GEN-FIRST:event_jPopupMenu1PopupMenuWillBecomeVisible
        Polygon pol = ts.getAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
        jMenuItem1.setEnabled(pol!=null);
        jMenuItem2.setEnabled(pol!=null);
    }//GEN-LAST:event_jPopupMenu1PopupMenuWillBecomeVisible


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPopupMenu jPopupMenu1;
    // End of variables declaration//GEN-END:variables

    /**
     * Returns whether or not this TMAViewPanel currently displays a point with a given coordinate
     * x and y. X and y come from the original image dimension (i.e. independent from the current zoom).
     * @param x The x-coord of the queried locus.
     * @param y The y-coord of the queried locus.
     * @return True if the locus is currently displayed in the container JScrollPane. False if the locus falls outside of the JScrollPane.
     */
    @Override
    public boolean isShowing(int x, int y) {
        if (t==null || getOpenSlide()==null) return false;
        JScrollPane jsp = t.getTMAViewContainer();
        Rectangle r = jsp.getViewport().getVisibleRect();
        return r.contains(x*getZoom(), y*getZoom());
    }
    
    /**
     * Displays a TMAspot.
     * @param ts The TMAspot to be displayed.
     * @param forceRepaint If true, the given TMAspot is repainted in any case. If false, 
     * the given TMAspot is only repainted, if it is not equal to the currently visible TMAspot.
     */
    @Override
    public void showTMAspot(TMAspot ts, boolean forceRepaint) {
        if (forceRepaint || this.ts!=ts) {
            String text = t.getStatusMessageLabel().getText();
            if (ts!=null && ts.getNDPI()!=null) {
                t.setStatusMessageLabel("Loading Image " + ts.getName() + " ...");
                setOpenSlide(ts.getNDPI());
                Image_Width = (int) ts.getNDPI().getLevel0Width();
                Image_Height = (int) ts.getNDPI().getLevel0Height();
                setZoom(ts.getCenter().getZoom());
                this.setPreferredSize(new Dimension(Image_Width, Image_Height));
                this.setSize(new Dimension(Image_Width, Image_Height));
                revalidate();
            } else {
                setOpenSlide(null);
            }
            t.setStatusMessageLabel(text);

            this.ts = ts;
            //this.repaint();
        }
    }
    
    @Override
    public void paintComponent(Graphics g) {
        ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        super.paintComponent(g);
        
        double z = getZoom();
        try {
            int x_min = (int)(ts.getCenter().getTMAViewContainer().getHorizontalScrollBar().getValue()/z);
            int y_min = (int)(ts.getCenter().getTMAViewContainer().getVerticalScrollBar().getValue()/z);
            int x_max = (int)(x_min+ts.getCenter().getTMAViewContainer().getViewport().getWidth()/z);
            int y_max = (int)(y_min+ts.getCenter().getTMAViewContainer().getViewport().getHeight()/z);
            
            if (ts!=null) {
                for (Pluggable p: ts.getCenter().getPlugins()) {
                    try {
                        p.drawInformationPreNuclei(ts, g, z, x_min, y_min, x_max, y_max);
                    } catch (Error | Exception er) { 
                        Logger.getLogger(TMA_view_panel.class.getName()).log(java.util.logging.Level.WARNING, er.getMessage());
                    }
                }
                drawCellCounts(ts, g, z, x_min, y_min, x_max, y_max);
                drawAreas(ts, g, z, x_min, y_min, x_max, y_max);
                drawDensitySoft(ts, g, z, x_min, y_min, x_max, y_max);
                drawScaleBar(ts, g, z, x_min, y_min, x_max, y_max);
                
                for (Pluggable p: ts.getCenter().getPlugins()) {
                    try {
                        p.drawInformationPostNuclei(ts, g, z, x_min, y_min, x_max, y_max);
                    } catch (Error | Exception er) { 
                        Logger.getLogger(TMA_view_panel.class.getName()).log(java.util.logging.Level.WARNING, er.getMessage());
                    }
                }
            }
        } catch (Exception e) {
        }
    }
    
    /**
     * Draws the scale bar on the bottom right side of the graphics. The scale
     * bar indicates the micrometers shown in the image, based on the information
     * of the scale in the NDPI image and the current zoom.
     * @param ts The current TMAspot.
     * @param g The graphics to draw on.
     * @param z The current zoom factor.
     * @param x_min The min x-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param y_min The min y-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param x_max The max x-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param y_max The max y-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     
     */
    private static void drawScaleBar(TMAspot ts, Graphics g, double z, int x_min, int y_min, int x_max, int y_max) {
        try {
            int length = 80; // scalebar length in pixels
            int offsetx = 50; // offset from the image right border
            int offsety = 20; // offset from the image buttom border

            SortedProperties props = ts.getProperties();
            String unit = "μm";
            double mmp = Double.parseDouble((String) props.get("openslide.mpp-x"));

            // format the scale
            double scale = (length*mmp)/z;

            if (unit.toLowerCase().equals("centimeter")) {
                scale = 10000 * scale;
                unit = "μm";
            } else if (unit.toLowerCase().equals("inch")) {
                scale = 25400 * scale;
                unit = "μm";
            }

            if (scale>=1000 && unit.equals("μm")) {
                scale = scale / 1000;
                unit = "mm";
            }

            String scaleString = String.format( "%.0f", scale ) + " " + unit;

            Graphics2D g2d = (Graphics2D) g;
            g2d.setColor(Color.gray.darker());
            g2d.setStroke(new BasicStroke(3));
            g2d.drawLine((int)(z*x_max-length-offsetx), (int)(z*y_max-offsety-18), (int)(z*x_max-offsetx), (int)(z*y_max-offsety-18));
            g2d.setFont(g2d.getFont().deriveFont(Font.BOLD));
            g2d.drawString(scaleString, (int)(z*x_max-length-offsetx), (int)(z*y_max-offsety));
        } catch (Exception e) {
            
        }
        
    }
    

    /**
     * Displays a TMAspot.
     * @param ts The TMAspot to be displayed.
     */
    public void showTMAspot(TMAspot ts) {
        showTMAspot(ts, false);
    }

    /**
     * Returns the currently displayed TMAspot.
     * @return The currently displayed TMAspot. Null if there is none.
     */
    @Override
    public TMAspot getTMAspot() {
        return ts;
    }

    /**
     * returns the original image width.
     * @return The image width.
     */
    @Override
    public int getImageWidth() {
        return Image_Width;
    }
    
    /**
     * returns the original image height.
     * @return The image height.
     */
    @Override
    public int getImageHeight() {
        return Image_Height;
    }

    /**
     * Returns the recent drawn polyline. Important for the drawing of including or excluding areas.
     * @return The recently drawn polyline x-coords.
     */
    @Override
    public List<Integer> getRecentPolyline_x() {
        return RECENT_POLYLINE_X;
    }
    
    /**
     * Returns the recent drawn polyline. Important for the drawing of including or excluding areas.
     * @return The recently drawn polyline y-coords.
     */
    @Override
    public List<Integer> getRecentPolyline_y() {
        return RECENT_POLYLINE_Y;
    }

    /**
     * Indicates that the user does not want to draw an area anymore. The recent polyline is cleared.
     */
    @Override
    public void reliefRecentPolyLine() {
        RECENT_POLYLINE_X.clear();
        RECENT_POLYLINE_Y.clear();
        repaint();
    }
    
    /**
     * Enables / disables the popup menu.
     * @param b If true, the popup menu is enabled. Otherwise disabled.
     */
    @Override
    public void enablePopupMenu(boolean b) {
        if (b) {
            setComponentPopupMenu(jPopupMenu1);
        } else {
            setComponentPopupMenu(null);
        }
    }

    @Override
    public Image getImage() {
        try {
            return getOpenSlide().createThumbnailImage(200);
        } catch (IOException ex) {
            Logger.getLogger(WholeSlide_view_panel.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    /**
     * Sets the coordinates x, y of the image into the center of the current view. After calling, the
     * user sees point x, y of the original image in the middle of the TMA view screen, at the same zoom level as before.
     * @param x The x coordinate as original image coordinate.
     * @param y The y coordinate as original image coordinate.
     */
    @Override
    public void jumpToVisibleLocus(int x, int y) {
        JScrollPane jsp = t.getTMAViewContainer();
        Rectangle r = jsp.getViewport().getViewRect();
        Point Pold = new Point(r.x + r.width/2, r.y + r.height/2);
        int dx = (int)(x)-(int)(Pold.x/getZoom());
        int dy = (int)(y)-(int)(Pold.y/getZoom());
        r.setLocation((int)(dx*getZoom()), (int)(dy*getZoom()));
        jsp.getViewport().scrollRectToVisible(r);
        
        t.showTMAspotLocalZoom(x,y);
        t.showTMAspotLocalZoomOnPreview(x,y);
    }

    
}