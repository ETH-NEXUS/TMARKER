/*
 * Copyright (C) 2015 peschuef
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package tmarker;

import TMARKERPluginInterface.Pluggable;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.io.IOException;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import static tmarker.TMA_view_panel.cursor_cross;
import static tmarker.TMA_view_panel.cursor_hand;
import static tmarker.TMA_view_panel.recentPolyline_x;
import static tmarker.TMA_view_panel.recentPolyline_y;
import tmarker.TMAspot.TMALabel;
import tmarker.TMAspot.TMApoint;
import tmarker.TMAspot.TMAspot;
import static tmarker.TMAspot_view_panel.drawCellCounts;
import static tmarker.TMAspot_view_panel.drawAreas;
import static tmarker.TMAspot_view_panel.drawDensitySoft;
import tmarker.misc.Misc;
import tmarker.misc.SortedProperties;
import tmarker.misc.ZoomableNDPIPanel;

/**
 *
 * @author Peter J. Schueffler
 */
public class WholeSlide_view_panel extends ZoomableNDPIPanel implements TMA_view_panel {
    
    tmarker t = null;
    TMAspot ts = null;
    Point MouseLocus = new Point(0,0);
    int Image_Width = 0;
    int Image_Height = 0;

    public WholeSlide_view_panel(tmarker t) {
        initComponents();
        this.t = t;
        setZoomMin(0.001);
        setZoomMax(1.0);
        setMouseWheelEnabled(false);
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPopupMenu1 = new javax.swing.JPopupMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();

        jPopupMenu1.addPopupMenuListener(new javax.swing.event.PopupMenuListener() {
            public void popupMenuCanceled(javax.swing.event.PopupMenuEvent evt) {
            }
            public void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent evt) {
            }
            public void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent evt) {
                jPopupMenu1PopupMenuWillBecomeVisible(evt);
            }
        });

        jMenuItem1.setText("Delete Points in Area");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jPopupMenu1.add(jMenuItem1);

        jMenuItem2.setText("Copy ROI to Selected Images");
        jMenuItem2.setToolTipText("");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jPopupMenu1.add(jMenuItem2);

        addMouseWheelListener(new java.awt.event.MouseWheelListener() {
            public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
                formMouseWheelMoved(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
        });
        setLayout(new java.awt.BorderLayout());
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        // if we are in background color correction modus, do this.
        if (t.isInBGCorrectionModus()) {
            t.performBGCorrection((int)(evt.getX()/getZoom()), (int)(evt.getY()/getZoom())); 
        } 
        // if we are in polygon drawing modus, do this.
        else if (evt.getClickCount() == 1 && (t.isInDrawIncludingAreaModus() || t.isInDrawExcludingAreaModus())) {
            recentPolyline_x.add((int)(evt.getX()/getZoom()));
            recentPolyline_y.add((int)(evt.getY()/getZoom()));
            repaint();
        } else if (evt.getClickCount() > 1 && (t.isInDrawIncludingAreaModus() || t.isInDrawExcludingAreaModus())) {
            recentPolyline_x.add((int)(evt.getX()/getZoom()));
            recentPolyline_y.add((int)(evt.getY()/getZoom()));
            int[] xs = new int[recentPolyline_x.size()];
            int[] ys = new int[recentPolyline_y.size()];
            for (int i=0; i<recentPolyline_x.size(); i++) {
                xs[i] = recentPolyline_x.get(i);
                ys[i] = recentPolyline_y.get(i);
            }
            if (t.isInDrawIncludingAreaModus()) {
                ts.getIncludingAreas().add(new Polygon(xs, ys, recentPolyline_x.size()));
            } else {
                ts.getExcludingAreas().add(new Polygon(xs, ys, recentPolyline_x.size()));
            }
            recentPolyline_x.clear();
            recentPolyline_y.clear();
            repaint();
        } 
        // if we are in polygon switching modus, do this.
        else if (t.isInSwitchAreaModus()) {
            ts.switchPolygonOnPoint((int)(evt.getPoint().x/getZoom()), (int)(evt.getPoint().y/getZoom()));
            repaint();
        } 
        // if we are in polygon deletion modus, do this.
        else if (t.isInDeleteAreaModus()) {
            ts.deletePolygonOnPoint((int)(evt.getPoint().x/getZoom()), (int)(evt.getPoint().y/getZoom()));
            repaint();
        } 
        // else...
        else {
            if(!evt.isControlDown()) {
                if (evt.getButton() == java.awt.event.MouseEvent.BUTTON1) { // the normal left button
                    Point p = new Point(evt.getPoint());
                    switch (t.getClickBehaviour()) {
                        case tmarker.CLICK_BEHAVIOUR_DELETE: { 
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                ts.removePoint(p_old);
                            } 
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_FLIP: {
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                if (t.getOptionDialog().isAutomaticESGSConversion()) {
                                    p_old.setGoldStandard(t.getGSNumberForLabeling());
                                }
                                p_old.flipLabel(false);
                            }
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_CORSTAIN_GRAD: {
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                if (t.getOptionDialog().isAutomaticESGSConversion()) {
                                    p_old.setGoldStandard(t.getGSNumberForLabeling());
                                }
                                p_old.flipStaining(false);
                            }
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_CORSTAIN_BIN: {
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                if (t.getOptionDialog().isAutomaticESGSConversion()) {
                                    p_old.setGoldStandard(t.getGSNumberForLabeling());
                                }
                                p_old.flipStaining(true);
                            }
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_ADD_POS: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_POS, ts.getCenter().getCurrentStainingIntensity());
                            } 
                            //tp.calculateStaining();
                            tp.setGoldStandard(t.getGSNumberForLabeling());
                            ts.addPoint(tp);
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_ADD_NEG: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_NEG, ts.getCenter().getCurrentStainingIntensity());
                            }
                            //tp.calculateStaining();
                            tp.setGoldStandard(t.getGSNumberForLabeling());
                            ts.addPoint(tp);
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_ADD_UNK: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_UNK, ts.getCenter().getCurrentStainingIntensity());
                            }
                            //tp.calculateStaining();
                            tp.setGoldStandard(t.getGSNumberForLabeling());
                            ts.addPoint(tp);
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_ADD_BG: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_BG);
                            }
                            //tp.calculateStaining();
                            tp.setGoldStandard(t.getGSNumberForLabeling());
                            ts.addPoint(tp);
                            break;
                        }
                        case tmarker.CLICK_BEHAVIOUR_NONE: {
                            break;
                        }
                        default: break;
                    }
                    repaint();
                    
                    ts.dispStainingInfo();
                }
            }
        }
        if (!t.getSelectedTMAspots(false).contains(ts)) {
            for (TMAspot ts_: t.getTMAspots()) {
                    ts_.setSelected(ts_==ts);
                }
        }
    }//GEN-LAST:event_formMouseClicked

    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        MouseLocus = evt.getPoint();
    }//GEN-LAST:event_formMousePressed

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        setCursor(cursor_cross);
    }//GEN-LAST:event_formMouseReleased

    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
       TMApoint p_old = ts.getPointAt((int)(MouseLocus.getX()/getZoom()), (int)(MouseLocus.getY()/getZoom()), ts.getParam_r(), true);
        if (p_old!=null) {
            p_old.x=(int)(evt.getX()/getZoom());
            p_old.y=(int)(evt.getY()/getZoom());
            if (t.getOptionDialog().isAutomaticESGSConversion()) {
                p_old.setGoldStandard(t.getGSNumberForLabeling());
            }
            MouseLocus = evt.getPoint();
            repaint();
            ts.dispStainingInfo();
        } else { 
            setCursor(cursor_hand);
            JScrollPane jsp = t.getTMAViewContainer();
            Point P = evt.getPoint();
            int dx = MouseLocus.x-P.x;
            int dy = MouseLocus.y-P.y;
            Rectangle r = jsp.getViewport().getVisibleRect();
            r.setLocation(r.x+dx, r.y+dy);
            jsp.getViewport().scrollRectToVisible(r);
        }
    }//GEN-LAST:event_formMouseDragged

    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        try {
            t.setStatusMessageLabel("x = " + Integer.toString((int)(evt.getX()/getZoom())) + ", y = " + Integer.toString((int)(evt.getY()/getZoom())));
            t.showTMAspotLocalZoom((int)(evt.getX()/getZoom()), (int)(evt.getY()/getZoom()));
            t.showTMAspotLocalZoomOnPreview((int)(evt.getX()/getZoom()), (int)(evt.getY()/getZoom()));
            if (t.isInDrawIncludingAreaModus() || t.isInDrawExcludingAreaModus() || t.isInDeleteAreaModus()) {
               setCursor(cursor_hand);
            } else{
                setCursor(cursor_cross);
            }
            if (ts.hasStainingEstimation()) {
                TMApoint tp = ts.getPointAt((int)(evt.getX()/getZoom()), (int) (evt.getY()/getZoom()), ts.getParam_r(), true);
                if (tp!=null) {
                    setCursor(cursor_hand);
                    String text = "<html><b>" + ts.getName() + "</b><br>"+
                            "TMA point (" + tp.x + ", " + tp.y + ")<br>";
                    text += "staining intensity: " + tp.getStaining() + "<br>";
                    text += tp.isGoldStandard() ? "is Gold Standard from labeler " + (tp.getGoldStandard()==TMApoint.CONSENSUS?"(consens)" : tp.getGoldStandard()) + "<br>" : "is computationally estimated<br>";
                    text += tp.isTrainingPoint(false) ? "was used for detection training <br>" : "";
                    text += tp.isTrainingPoint(true) ? "was used for classification training <br>" : "";
                    setToolTipText(text);
                } else {
                    setCursor(cursor_cross);
                    setToolTipText(null);
                }
            } else {
                setCursor(cursor_cross);
                setToolTipText(null);
            }
        } catch (Exception ex) {
            
        }
    }//GEN-LAST:event_formMouseMoved

    private void formMouseWheelMoved(java.awt.event.MouseWheelEvent evt) {//GEN-FIRST:event_formMouseWheelMoved
        int amount = evt.getWheelRotation();
        Rectangle rect = getVisibleRect();
        double oldZoom = t.getZoom();
        if (amount <= 0) {
            t.setZoomSlider(Math.max((int) (100*getZoom()+1), (int) (100*getZoom() * getZoomFactor())));
        } else {
            t.setZoomSlider((int) (100*getZoom() / getZoomFactor()));
        }
        double newZoom = t.getZoom();
        double zfactor = newZoom / oldZoom;
        int dx = (int)((zfactor-1)*(evt.getX()));
        int dy = (int)((zfactor-1)*(evt.getY()));
        rect.translate(dx, dy);
        this.scrollRectToVisible(rect);
    }//GEN-LAST:event_formMouseWheelMoved

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        Polygon pol = ts.getAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
        if (pol!=null) {
            ts.deletePointsInArea(pol);
            repaint();
        }
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        boolean including = true;
        Polygon pol = ts.getIncludingAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
        if (pol==null) {
            pol = ts.getExcludingAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
            including = false;
        }
        if (pol!=null) {
            List<TMAspot> tss = t.getSelectedTMAspots();
            for (TMAspot ts_: tss) {
                boolean addthispol = true;
                List<Polygon> areas_tmp = ts_.getExcludingAreas();
                areas_tmp.addAll(ts_.getIncludingAreas());
                for (Polygon p_tmp: areas_tmp) {
                    if (Misc.SamePolygons(p_tmp, pol)) {
                        addthispol = false;
                        break;
                    }
                }
                if (addthispol) {
                    if (including) ts_.getIncludingAreas().add(new Polygon(pol.xpoints, pol.ypoints, pol.npoints));
                    else ts_.getExcludingAreas().add(new Polygon(pol.xpoints, pol.ypoints, pol.npoints));
                }
            }
        }
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    private void jPopupMenu1PopupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent evt) {//GEN-FIRST:event_jPopupMenu1PopupMenuWillBecomeVisible
        Polygon pol = ts.getAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
        jMenuItem1.setEnabled(pol!=null);
        jMenuItem2.setEnabled(pol!=null);
    }//GEN-LAST:event_jPopupMenu1PopupMenuWillBecomeVisible


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPopupMenu jPopupMenu1;
    // End of variables declaration//GEN-END:variables

    /**
     * Returns whether or not this TMAViewPanel currently displays a point with a given coordinate
     * x and y. X and y come from the original image dimension (i.e. independent from the current zoom).
     * @param x The x-coord of the queried locus.
     * @param y The y-coord of the queried locus.
     * @return True if the locus is currently displayed in the container JScrollPane. False if the locus falls outside of the JScrollPane.
     */
    @Override
    public boolean isShowing(int x, int y) {
        if (t==null || getOpenSlide()==null) return false;
        JScrollPane jsp = t.getTMAViewContainer();
        Rectangle r = jsp.getViewport().getVisibleRect();
        return r.contains(x*getZoom(), y*getZoom());
    }
    
    /**
     * Displays a TMAspot.
     * @param ts The TMAspot to be displayed.
     * @param forceRepaint If true, the given TMAspot is repainted in any case. If false, 
     * the given TMAspot is only repainted, if it is not equal to the currently visible TMAspot.
     */
    @Override
    public void showTMAspot(TMAspot ts, boolean forceRepaint) {
        if (forceRepaint || this.ts!=ts) {
            String text = t.getStatusMessageLabel().getText();
            if (ts!=null && ts.getNDPI()!=null) {
                t.setStatusMessageLabel("Loading Image " + ts.getName() + " ...");
                setOpenSlide(ts.getNDPI());
                Image_Width = (int) ts.getNDPI().getLevel0Width();
                Image_Height = (int) ts.getNDPI().getLevel0Height();
                setZoom(ts.getCenter().getZoom());
                this.setPreferredSize(new Dimension(Image_Width, Image_Height));
                this.setSize(new Dimension(Image_Width, Image_Height));
                revalidate();
            } else {
                setOpenSlide(null);
            }
            t.setStatusMessageLabel(text);

            this.ts = ts;
            //this.repaint();
        }
    }
    
    @Override
    public void paintComponent(Graphics g) {
        ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        super.paintComponent(g);
        
        double z = getZoom();
        try {
            int x_min = (int)(ts.getCenter().getTMAViewContainer().getHorizontalScrollBar().getValue()/z);
            int y_min = (int)(ts.getCenter().getTMAViewContainer().getVerticalScrollBar().getValue()/z);
            int x_max = (int)(x_min+ts.getCenter().getTMAViewContainer().getViewport().getWidth()/z);
            int y_max = (int)(y_min+ts.getCenter().getTMAViewContainer().getViewport().getHeight()/z);
            
            if (ts!=null) {
                for (Pluggable p: ts.getCenter().getPlugins()) {
                    try {
                        p.drawInformationPreNuclei(ts, g, z, x_min, y_min, x_max, y_max);
                    } catch (Error | Exception er) { 
                        Logger.getLogger(TMA_view_panel.class.getName()).log(java.util.logging.Level.WARNING, er.getMessage());
                    }
                }
                drawCellCounts(ts, g, z, x_min, y_min, x_max, y_max);
                drawAreas(ts, g, z, x_min, y_min, x_max, y_max);
                drawDensitySoft(ts, g, z, x_min, y_min, x_max, y_max);
                drawScaleBar(ts, g, z, x_min, y_min, x_max, y_max);
                
                for (Pluggable p: ts.getCenter().getPlugins()) {
                    try {
                        p.drawInformationPostNuclei(ts, g, z, x_min, y_min, x_max, y_max);
                    } catch (Error | Exception er) { 
                        Logger.getLogger(TMA_view_panel.class.getName()).log(java.util.logging.Level.WARNING, er.getMessage());
                    }
                }
            }
        } catch (Exception e) {
        }
        
    }
    
    /**
     * Draws the scale bar on the bottom right side of the graphics. The scale
     * bar indicates the micrometers shown in the image, based on the information
     * of the scale in the NDPI image and the current zoom.
     * @param ts The current TMAspot.
     * @param g The graphics to draw on.
     * @param z The current zoom factor.
     * @param x_min The min x-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param y_min The min y-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param x_max The max x-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param y_max The max y-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     
     */
    private static void drawScaleBar(TMAspot ts, Graphics g, double z, int x_min, int y_min, int x_max, int y_max) {
        try {
            int length = 80; // scalebar length in pixels
            int offsetx = 50; // offset from the image right border
            int offsety = 20; // offset from the image buttom border

            SortedProperties props = ts.getProperties();
            String unit = "μm";
            double mmp = Double.parseDouble((String) props.get("openslide.mpp-x"));

            // format the scale
            double scale = (length*mmp)/z;

            if (unit.toLowerCase().equals("centimeter")) {
                scale = 10000 * scale;
                unit = "μm";
            } else if (unit.toLowerCase().equals("inch")) {
                scale = 25400 * scale;
                unit = "μm";
            }

            if (scale>=1000 && unit.equals("μm")) {
                scale = scale / 1000;
                unit = "mm";
            }

            String scaleString = String.format( "%.0f", scale ) + " " + unit;

            Graphics2D g2d = (Graphics2D) g;
            g2d.setColor(Color.gray.darker());
            g2d.setStroke(new BasicStroke(3));
            g2d.drawLine((int)(z*x_max-length-offsetx), (int)(z*y_max-offsety-18), (int)(z*x_max-offsetx), (int)(z*y_max-offsety-18));
            g2d.setFont(g2d.getFont().deriveFont(Font.BOLD));
            g2d.drawString(scaleString, (int)(z*x_max-length-offsetx), (int)(z*y_max-offsety));
        } catch (Exception e) {
            
        }
        
    }
    

    /**
     * Displays a TMAspot.
     * @param ts The TMAspot to be displayed.
     */
    public void showTMAspot(TMAspot ts) {
        showTMAspot(ts, false);
    }

    /**
     * Returns the currently displayed TMAspot.
     * @return The currently displayed TMAspot. Null if there is none.
     */
    @Override
    public TMAspot getTMAspot() {
        return ts;
    }

    /**
     * returns the original image width.
     * @return The image width.
     */
    @Override
    public int getImageWidth() {
        return Image_Width;
    }
    
    /**
     * returns the original image height.
     * @return The image height.
     */
    @Override
    public int getImageHeight() {
        return Image_Height;
    }

    /**
     * Returns the recent drawn polyline. Important for the drawing of including or excluding areas.
     * @return The recently drawn polyline x-coords.
     */
    @Override
    public List<Integer> getRecentPolyline_x() {
        return recentPolyline_x;
    }
    
    /**
     * Returns the recent drawn polyline. Important for the drawing of including or excluding areas.
     * @return The recently drawn polyline y-coords.
     */
    @Override
    public List<Integer> getRecentPolyline_y() {
        return recentPolyline_y;
    }

    /**
     * Indicates that the user does not want to draw an area anymore. The recent polyline is cleared.
     */
    @Override
    public void reliefRecentPolyLine() {
        recentPolyline_x.clear();
        recentPolyline_y.clear();
        repaint();
    }
    
    /**
     * Enables / disables the popup menu.
     * @param b If true, the popup menu is enabled. Otherwise disabled.
     */
    @Override
    public void enablePopupMenu(boolean b) {
        if (b) {
            setComponentPopupMenu(jPopupMenu1);
        } else {
            setComponentPopupMenu(null);
        }
    }

    @Override
    public Image getImage() {
        try {
            return getOpenSlide().createThumbnailImage(200);
        } catch (IOException ex) {
            Logger.getLogger(WholeSlide_view_panel.class.getName()).log(Level.SEVERE, null, ex);
        }
        return null;
    }

    
}