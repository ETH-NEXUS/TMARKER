/*
 * Copyright (C) 2015 peschuef
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package tmarker;

import TMARKERPluginInterface.Pluggable;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.RadialGradientPaint;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.logging.Logger;
import javax.swing.JScrollPane;
import javax.swing.Timer;
import tmarker.TMAspot.TMALabel;
import tmarker.TMAspot.TMApoint;
import tmarker.TMAspot.TMAspot;
import tmarker.misc.Misc;
import tmarker.misc.ZoomableImagePanel;
import static tmarker.TMA_view_panel.CURSOR_CROSS;
import static tmarker.TMA_view_panel.CURSOR_HAND;
import static tmarker.TMA_view_panel.RECENT_POLYLINE_X;
import static tmarker.TMA_view_panel.RECENT_POLYLINE_Y;

/**
 *
 * @author Peter J. Schueffler
 */
public class TMAspot_view_panel extends ZoomableImagePanel implements TMA_view_panel {
    tmarker t = null;
    TMAspot ts = null;
    Point MouseLocus = new Point(0,0);
    int Image_Width = 0;
    int Image_Height = 0;
    
    boolean wasDoubleClick;
    Timer timer;
        
    
    public TMAspot_view_panel(tmarker t) {
        initComponents();
        this.t = t;
        setZoomMin(0.01);
        setZoomMax(4.0);
        setMouseWheelEnabled(false);
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPopupMenu1 = new javax.swing.JPopupMenu();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();

        jPopupMenu1.addPopupMenuListener(new javax.swing.event.PopupMenuListener() {
            public void popupMenuCanceled(javax.swing.event.PopupMenuEvent evt) {
            }
            public void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent evt) {
            }
            public void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent evt) {
                jPopupMenu1PopupMenuWillBecomeVisible(evt);
            }
        });

        jMenuItem1.setText("Delete Points in Area");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jPopupMenu1.add(jMenuItem1);

        jMenuItem2.setText("Copy ROI to Selected Images");
        jMenuItem2.setToolTipText("");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jPopupMenu1.add(jMenuItem2);

        addMouseWheelListener(new java.awt.event.MouseWheelListener() {
            public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
                formMouseWheelMoved(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                formMouseClicked(evt);
            }
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });
        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                formMouseMoved(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 259, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 213, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
        // if we are in background color correction modus, do this.
        if (t.isInBGCorrectionModus()) {
            t.performBGCorrection((int)(evt.getX()/getZoom()), (int)(evt.getY()/getZoom())); 
                }
        // if we are in polygon drawing modus, do this.
        else if (evt.getClickCount() == 1 && (t.isInDrawIncludingAreaModus() || t.isInDrawExcludingAreaModus())) {
            RECENT_POLYLINE_X.add((int)(evt.getX()/getZoom()));
            RECENT_POLYLINE_Y.add((int)(evt.getY()/getZoom()));
            repaint();
        } else if (evt.getClickCount() > 1 && (t.isInDrawIncludingAreaModus() || t.isInDrawExcludingAreaModus())) {
            RECENT_POLYLINE_X.add((int)(evt.getX()/getZoom()));
            RECENT_POLYLINE_Y.add((int)(evt.getY()/getZoom()));
            int[] xs = new int[RECENT_POLYLINE_X.size()];
            int[] ys = new int[RECENT_POLYLINE_Y.size()];
            for (int i=0; i<RECENT_POLYLINE_X.size(); i++) {
                xs[i] = RECENT_POLYLINE_X.get(i);
                ys[i] = RECENT_POLYLINE_Y.get(i);
            }
            if (t.isInDrawIncludingAreaModus()) {
                ts.getIncludingAreas().add(new Polygon(xs, ys, RECENT_POLYLINE_X.size()));
                } else {
                ts.getExcludingAreas().add(new Polygon(xs, ys, RECENT_POLYLINE_X.size()));
                }
            RECENT_POLYLINE_X.clear();
            RECENT_POLYLINE_Y.clear();
                repaint();
                }
        // if we are in polygon switching modus, do this.
                    else if (t.isInSwitchAreaModus()) {
            ts.switchPolygonOnPoint((int)(evt.getPoint().x/getZoom()), (int)(evt.getPoint().y/getZoom()));
                        repaint();
        } 
        // if we are in polygon deletion modus, do this.
                    else if (t.isInDeleteAreaModus()) {
            ts.deletePolygonOnPoint((int)(evt.getPoint().x/getZoom()), (int)(evt.getPoint().y/getZoom()));
                        repaint();
        } 
        // else...
                    else {
            if(!evt.isControlDown()) {
                if (evt.getButton() == java.awt.event.MouseEvent.BUTTON1) { // the normal left button
                    Point p = new Point(evt.getPoint());
                                switch (t.getClickBehaviour()) {
                                    case tmarker.CLICK_BEHAVIOUR_DELETE: {
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                            ts.removePoint(p_old);
                                        }
                                        break;
                                    }
                                    case tmarker.CLICK_BEHAVIOUR_FLIP: {
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                            if (t.getOptionDialog().isAutomaticESGSConversion()) {
                                                p_old.setGoldStandard(t.getGSNumberForLabeling());
                                            }
                                            p_old.flipLabel(false);
                                        }
                                        break;
                                    }
                                    case tmarker.CLICK_BEHAVIOUR_CORSTAIN_GRAD: {
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                            if (t.getOptionDialog().isAutomaticESGSConversion()) {
                                                p_old.setGoldStandard(t.getGSNumberForLabeling());
                                            }
                                            p_old.flipStaining(false);
                                        }
                                        break;
                                    }
                                    case tmarker.CLICK_BEHAVIOUR_CORSTAIN_BIN: {
                            TMApoint p_old = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (p_old!=null) {
                                            if (t.getOptionDialog().isAutomaticESGSConversion()) {
                                                p_old.setGoldStandard(t.getGSNumberForLabeling());
                                            }
                                            p_old.flipStaining(true);
                                        }
                                        break;
                                    }
                                    case tmarker.CLICK_BEHAVIOUR_ADD_POS: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_POS, ts.getCenter().getCurrentStainingIntensity());
                                        }
                                        //tp.calculateStaining();
                                        tp.setLabel(TMALabel.LABEL_POS);
                                        tp.setStaining(ts.getCenter().getCurrentStainingIntensity());
                                        tp.setGoldStandard(t.getGSNumberForLabeling());
                                        ts.addPoint(tp);
                                        break;
                                    }
                                    case tmarker.CLICK_BEHAVIOUR_ADD_NEG: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_NEG, ts.getCenter().getCurrentStainingIntensity());
                                        }
                                        //tp.calculateStaining();
                                        tp.setLabel(TMALabel.LABEL_NEG);
                                        tp.setStaining(ts.getCenter().getCurrentStainingIntensity());
                                        tp.setGoldStandard(t.getGSNumberForLabeling());
                                        ts.addPoint(tp);
                                        break;
                                    }
                                    case tmarker.CLICK_BEHAVIOUR_ADD_UNK: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_UNK, ts.getCenter().getCurrentStainingIntensity());
                                        }
                                        //tp.calculateStaining();
                                        tp.setLabel(TMALabel.LABEL_UNK);
                                        tp.setStaining(ts.getCenter().getCurrentStainingIntensity());
                                        tp.setGoldStandard(t.getGSNumberForLabeling());
                                        ts.addPoint(tp);
                                        break;
                                    }
                                    case tmarker.CLICK_BEHAVIOUR_ADD_BG: {
                            TMApoint tp = ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), true);
                            if (tp==null) {
                                tp = new TMApoint(ts, (int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), TMALabel.LABEL_BG);
                                        }
                                        //tp.calculateStaining();
                                        tp.setLabel(TMALabel.LABEL_BG);
                                        tp.setGoldStandard(t.getGSNumberForLabeling());
                                        ts.addPoint(tp);
                                        break;
                                    }
                                    case tmarker.CLICK_BEHAVIOUR_NONE: {
                                        break;
                                    }
                        default: break;
                                }
                                repaint();

                                ts.dispStainingInfo();
                            }
                        }
                        // Allow the plugins to do s.th. with the TMApoint
            Point p = new Point(evt.getPoint());
            for (Pluggable plugin: t.getPlugins()) {
                plugin.TMAspotMouseClicked(ts, ts.getPointAt((int)(p.getX()/getZoom()), (int)(p.getY()/getZoom()), ts.getParam_r(), false), evt);
                        }
                    }
        if (!t.getSelectedTMAspots(false).contains(ts)) {
            for (TMAspot ts_: t.getTMAspots()) {
                    ts_.setSelected(ts_==ts);
            }
        }

    }//GEN-LAST:event_formMouseClicked

    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        MouseLocus = evt.getPoint();
    }//GEN-LAST:event_formMousePressed

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        setCursor(CURSOR_CROSS);
    }//GEN-LAST:event_formMouseReleased

    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        TMApoint p_old = ts.getPointAt((int)(MouseLocus.getX()/getZoom()), (int)(MouseLocus.getY()/getZoom()), ts.getParam_r(), true);
        if (p_old!=null) {
            p_old.x=(int)(evt.getX()/getZoom());
            p_old.y=(int)(evt.getY()/getZoom());
            if (t.getOptionDialog().isAutomaticESGSConversion()) {
                p_old.setGoldStandard(t.getGSNumberForLabeling());
            }
            MouseLocus = evt.getPoint();
            repaint();
            ts.dispStainingInfo();
        } else { 
            setCursor(CURSOR_HAND);
            JScrollPane jsp = t.getTMAViewContainer();
            Point P = evt.getPoint();
            int dx = MouseLocus.x-P.x;
            int dy = MouseLocus.y-P.y;
            Rectangle r = jsp.getViewport().getVisibleRect();
            r.setLocation(r.x+dx, r.y+dy);
            jsp.getViewport().scrollRectToVisible(r);
        }
    }//GEN-LAST:event_formMouseDragged

    private void formMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseMoved
        try {
            BufferedImage bi = (BufferedImage)getImage();
            Color c = TMAspot.ColorAtPoint(bi, (int)(evt.getX()/getZoom()), (int)(evt.getY()/getZoom()));
            int r = c.getRed();
            int g = c.getGreen();
            int b = c.getBlue();

            t.setStatusMessageLabel("x = " + Integer.toString((int)(evt.getX()/getZoom())) + ", y = " + Integer.toString((int)(evt.getY()/getZoom())) + "     (R/G/B) = " + r + "/" + g + "/" + b);
            t.showTMAspotLocalZoom((int)(evt.getX()/getZoom()), (int)(evt.getY()/getZoom()));
            t.showTMAspotLocalZoomOnPreview((int)(evt.getX()/getZoom()), (int)(evt.getY()/getZoom()));
            if (t.isInDrawIncludingAreaModus() || t.isInDrawExcludingAreaModus() || t.isInDeleteAreaModus()) {
               setCursor(CURSOR_HAND);
            } else{
                setCursor(CURSOR_CROSS);
            }
            if (ts.hasStainingEstimation()) {
                TMApoint tp = ts.getPointAt((int)(evt.getX()/getZoom()), (int) (evt.getY()/getZoom()), ts.getParam_r(), true);
                if (tp!=null) {
                    setCursor(CURSOR_HAND);
                    String text = "<html><b>" + ts.getName() + "</b><br>"+
                            "TMA point (" + tp.x + ", " + tp.y + ")<br>";
                    text += "staining intensity: " + tp.getStaining() + "<br>";
                    text += tp.isGoldStandard() ? "is Gold Standard from labeler " + (tp.getGoldStandard()==TMApoint.CONSENSUS?"(consens)" : tp.getGoldStandard()) + "<br>" : "is computationally estimated<br>";
                    text += tp.isTrainingPoint(false) ? "was used for detection training <br>" : "";
                    text += tp.isTrainingPoint(true) ? "was used for classification training <br>" : "";
                    text += "Average RGB around this point: "; Color col = TMAspot.getAverageColorAtPoint(bi, tp.x, tp.y, ts.getParam_r(), false); text += col.getRed() + "/" + col.getGreen() + "/" + col.getBlue();
                    setToolTipText(text);
                } else {
                    setCursor(CURSOR_CROSS);
                    setToolTipText(null);
                }
            } else {
                setCursor(CURSOR_CROSS);
                setToolTipText(null);
            }
        } catch (Exception ex) {
            
        }
    }//GEN-LAST:event_formMouseMoved

    private void formMouseWheelMoved(java.awt.event.MouseWheelEvent evt) {//GEN-FIRST:event_formMouseWheelMoved
        int amount = evt.getWheelRotation();
        Rectangle rect = getVisibleRect();
        double oldZoom = t.getZoom();
        if (amount <= 0) {
            t.setZoomSlider(Math.max((int) (100*getZoom()+1), (int) (100*getZoom() * getZoomFactor())));
        } else {
            t.setZoomSlider((int) (100*getZoom() / getZoomFactor()));
        }
        double newZoom = t.getZoom();
        double zfactor = newZoom / oldZoom;
        int dx = (int)((zfactor-1)*(evt.getX()));
        int dy = (int)((zfactor-1)*(evt.getY()));
        rect.translate(dx, dy);
        this.scrollRectToVisible(rect);
    }//GEN-LAST:event_formMouseWheelMoved

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        Polygon pol = ts.getAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
        if (pol!=null) {
            ts.deletePointsInArea(pol);
            repaint();
        }
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        boolean including = true;
        Polygon pol = ts.getIncludingAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
        if (pol==null) {
            pol = ts.getExcludingAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
            including = false;
        }
        if (pol!=null) {
            List<TMAspot> tss = t.getSelectedTMAspots();
            for (TMAspot ts_: tss) {
                boolean addthispol = true;
                List<Polygon> areas_tmp = ts_.getExcludingAreas();
                areas_tmp.addAll(ts_.getIncludingAreas());
                for (Polygon p_tmp: areas_tmp) {
                    if (Misc.SamePolygons(p_tmp, pol)) {
                        addthispol = false;
                        break;
                    }
                }
                if (addthispol) {
                    if (including) ts_.getIncludingAreas().add(new Polygon(pol.xpoints, pol.ypoints, pol.npoints));
                    else ts_.getExcludingAreas().add(new Polygon(pol.xpoints, pol.ypoints, pol.npoints));
                }
            }
        }
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    private void jPopupMenu1PopupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent evt) {//GEN-FIRST:event_jPopupMenu1PopupMenuWillBecomeVisible
        Polygon pol = ts.getAreaOnPoint((int)(MouseLocus.x/getZoom()), (int)(MouseLocus.y/getZoom()));
        jMenuItem1.setEnabled(pol!=null);
        jMenuItem2.setEnabled(pol!=null);
    }//GEN-LAST:event_jPopupMenu1PopupMenuWillBecomeVisible


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JPopupMenu jPopupMenu1;
    // End of variables declaration//GEN-END:variables

    /**
     * Returns whether or not this TMAViewPanel currently displays a point with a given coordinate
     * x and y. X and y come from the original image dimension (i.e. independent from the current zoom).
     * @param x The x-coord of the queried locus.
     * @param y The y-coord of the queried locus.
     * @return True if the locus is currently displayed in the container JScrollPane. False if the locus falls outside of the JScrollPane.
     */
    @Override
    public boolean isShowing(int x, int y) {
        if (t==null || getImage()==null) return false;
        JScrollPane jsp = t.getTMAViewContainer();
        Rectangle r = jsp.getViewport().getVisibleRect();
        return r.contains(x*getZoom(), y*getZoom());
    }
    
    /**
     * Displays a TMAspot.
     * @param ts The TMAspot to be displayed.
     */
    @Override
    public void showTMAspot(TMAspot ts) {
        showTMAspot(ts, false);
    }
    
    /**
     * Displays a TMAspot.
     * @param ts The TMAspot to be displayed.
     * @param forceRepaint If true, the given TMAspot is repainted in any case. If false, 
     * the given TMAspot is only repainted, if it is not equal to the currently visible TMAspot.
     */
    @Override
    public void showTMAspot(TMAspot ts, boolean forceRepaint) {
        if (forceRepaint || this.ts!=ts) {
            String text = t.getStatusMessageLabel().getText();
            if (ts!=null) {
                t.setStatusMessageLabel("Loading " + ts.getName() + " ...");
                BufferedImage I = null;
                for (Pluggable p: ts.getCenter().getPlugins()) {
                    if (I==null) {
                        I = p.showAlternativeImage(ts);
                    }
                }
                if (I==null) {
                    I = ts.getBufferedImage();
                }
                if (getImage() != null) {
                    getImage().flush();
                }
                if (I != null) {
                    Image_Width = I.getWidth();
                    Image_Height = I.getHeight();
                    setImage(I);
                    setZoom(ts.getCenter().getZoom());
                    revalidate();
                    I.flush();
                    //System.gc();
                }
            } else {
                if (getImage() != null) {
                    getImage().flush();
                }
                setImage(null);
            }
            t.setStatusMessageLabel(text);

            this.ts = ts;
        }
    }

    /**
     * Draws the cell nuclei.
     * @param ts The TMAspot with the cell nuclei.
     * @param g The graphics on which is drawn.
     * @param z The scaling (zoom) factor of the image.
     * @param x_min The min x-coord which is visible in the zoomable image pane, relative to the original image coordinated (i.e. independent from the zoom).
     * @param y_min The min y-coord which is visible in the zoomable image pane, relative to the original image coordinated (i.e. independent from the zoom).
     * @param x_max The max x-coord which is visible in the zoomable image pane, relative to the original image coordinated (i.e. independent from the zoom).
     * @param y_max The max y-coord which is visible in the zoomable image pane, relative to the original image coordinated (i.e. independent from the zoom).
     */
    public static void drawCellCounts(TMAspot ts, Graphics g, double z, int x_min, int y_min, int x_max, int y_max) {
        if (g==null) {
            return;
        }
        
        int r = ts.getParam_r();
        int shape_gst = ts.getCenter().getOptionDialog().getLabelsShape_Gst();
        int shape_est = ts.getCenter().getOptionDialog().getLabelsShape_Est();;
        
        boolean poss  = (ts.getCenter().isShowingLabels()&ts.getCenter().isShowingPosLabels());
        boolean negs  = (ts.getCenter().isShowingLabels()&ts.getCenter().isShowingNegLabels());
        boolean unks  = (ts.getCenter().isShowingLabels()&ts.getCenter().isShowingUnkLabels());
        boolean bgs  = (ts.getCenter().isShowingLabels()&ts.getCenter().isShowingBGLabels());
        boolean stai  = (ts.getCenter().isShowingLabels()&ts.getCenter().isShowingStainedLabels());
        boolean ustai = (ts.getCenter().isShowingLabels()&ts.getCenter().isShowingUnstainedLabels());
        boolean est   = (ts.getCenter().isShowingLabels()&ts.getCenter().isShowingEstimatedLabels());
        boolean gsd   = (ts.getCenter().isShowingLabels()&ts.getCenter().isShowingGoldStandardLabels());
        
        // First draw Goldstandard
        if (poss) {
            drawCellCounts(g, ts.getPoints_GoldStandard(TMALabel.LABEL_POS), gsd, est, stai, ustai, ts.getCenter().getGSNumberForViewing(), Color.YELLOW, Color.BLUE, r, z, x_min, y_min, x_max, y_max, shape_gst);
        }
        if (negs) {
            drawCellCounts(g, ts.getPoints_GoldStandard(TMALabel.LABEL_NEG), gsd, est, stai, ustai, ts.getCenter().getGSNumberForViewing(), Color.YELLOW, Color.BLUE, r, z, x_min, y_min, x_max, y_max, shape_gst);
        }
        if (unks) {
            drawCellCounts(g, ts.getPoints_GoldStandard(TMALabel.LABEL_UNK), gsd, est, stai, ustai, ts.getCenter().getGSNumberForViewing(), Color.YELLOW, Color.BLUE, r, z, x_min, y_min, x_max, y_max, shape_gst);
        }
        if (bgs) {
            drawCellCounts(g, ts.getPoints_GoldStandard(TMALabel.LABEL_BG), gsd, est, stai, ustai, ts.getCenter().getGSNumberForViewing(), Color.YELLOW, Color.BLUE, r, z, x_min, y_min, x_max, y_max, shape_gst);
        }
        
        // Draw Estimated afterwards
        if (poss) {
            drawCellCounts(g, ts.getPoints_Estimated(TMALabel.LABEL_POS), gsd, est, stai, ustai, ts.getCenter().getGSNumberForViewing(), Color.YELLOW, Color.BLUE, r, z, x_min, y_min, x_max, y_max, shape_est);
        }
        if (negs) {
            drawCellCounts(g, ts.getPoints_Estimated(TMALabel.LABEL_NEG), gsd, est, stai, ustai, ts.getCenter().getGSNumberForViewing(), Color.YELLOW, Color.BLUE, r, z, x_min, y_min, x_max, y_max, shape_est);
        }
        if (unks) {
            drawCellCounts(g, ts.getPoints_Estimated(TMALabel.LABEL_UNK), gsd, est, stai, ustai, ts.getCenter().getGSNumberForViewing(), Color.YELLOW, Color.BLUE, r, z, x_min, y_min, x_max, y_max, shape_est);
        }
        if (bgs) {
            drawCellCounts(g, ts.getPoints_Estimated(TMALabel.LABEL_BG), gsd, est, stai, ustai, ts.getCenter().getGSNumberForViewing(), Color.YELLOW, Color.BLUE, r, z, x_min, y_min, x_max, y_max, shape_est);
        }
    }
    
    /**
     * Draws specific cell nuclei on a graphics.
     * @param g The graphics on which is drawn.
     * @param ps The TMApoint which can be drawn.
     * @param gsd If true, gold-standard points are drawn. Otherwise they are not drawn.
     * @param est If true, estimated points are drawn. Otherwise they are not drawn.
     * @param stai If true, stained points are drawn. Otherwise they are not drawn.
     * @param ustai If true, unstained points are drawn. Otherwise they are not drawn.
     * @param labelernum If >= 0 only points from this labeler are drawn. Otherwise all points might be drawn.
     * @param c_complement A color for the border of gold-standard points. The user can easily distinguish between gold-standard points and estimated ones by this border color.
     * @param c_training Color to mark training points.
     * @param r The radius of the points.
     * @param z The scaling (zoom) factor of the image.
     * @param x_min The min x-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param y_min The min y-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param x_max The max x-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param y_max The max y-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param shape The shape type to draw (indicated in the TMARKER options).
     */
    private static void drawCellCounts(Graphics g, List<TMApoint> ps, boolean gsd, boolean est, boolean stai, boolean ustai, byte labelernum, Color c_complement, Color c_training, int r, double z, int x_min, int y_min, int x_max, int y_max, int shape) {
        for (TMApoint tp: ps) {
            
            // if the point is in the viewport display it.
            if (tp.x >= x_min && tp.y >= y_min && tp.x < x_max && tp.y < y_max) {
            
                if ((tp.isGoldStandard() && gsd && (labelernum<0 || tp.getGoldStandard()==labelernum) || !tp.isGoldStandard() && est) && (tp.isStained() && stai || !tp.isStained() && ustai)) {
                    g.setColor(tp.getTMAspot().getCenter().getLabelsColor(tp.getLabel(), tp.getStaining()));

                    if (tp.getLabel()!=TMALabel.LABEL_BG && tp.getTMAspot().getCenter().isShowingTextLabels()) {
                        g.drawString(Byte.toString(tp.getStaining()), (int)((tp.getX()+r)*z), (int)((tp.getY()-r)*z));
                    }
                    if (shape == tmarker.LABELS_SHAPE_CIRCLE) {
                        g.fillOval((int)((tp.getX()-r)*z), (int)((tp.getY()-r)*z), (int)(2*r*z), (int)(2*r*z));
                    } else if (shape == tmarker.LABELS_SHAPE_CROSS) {
                        g.drawLine((int)((tp.getX()-r)*z), (int)(tp.getY()*z), (int)((tp.getX()+r)*z), (int)(tp.getY()*z));
                        g.drawLine((int)(tp.getX()*z), (int)((tp.getY()-r)*z), (int)(tp.getX()*z), (int)((tp.getY()+r)*z));
                    } else if (shape == tmarker.LABELS_SHAPE_CROSS_THICK) {
                        g.drawLine((int)((tp.getX()-r)*z), (int)(tp.getY()*z), (int)((tp.getX()+r)*z), (int)(tp.getY()*z));
                        g.drawLine((int)((tp.getX()-r)*z), (int)(tp.getY()*z)-1, (int)((tp.getX()+r)*z), (int)(tp.getY()*z)-1);
                        g.drawLine((int)((tp.getX()-r)*z), (int)(tp.getY()*z)+1, (int)((tp.getX()+r)*z), (int)(tp.getY()*z)+1);
                        g.drawLine((int)(tp.getX()*z), (int)((tp.getY()-r)*z), (int)(tp.getX()*z), (int)((tp.getY()+r)*z));
                        g.drawLine((int)(tp.getX()*z)-1, (int)((tp.getY()-r)*z), (int)(tp.getX()*z)-1, (int)((tp.getY()+r)*z));
                        g.drawLine((int)(tp.getX()*z)+1, (int)((tp.getY()-r)*z), (int)(tp.getX()*z)+1, (int)((tp.getY()+r)*z));  
                    } else { // shape == tmarker.LABELS_SHAPE_RECT
                        double f=0.6;
                        g.drawLine((int)((tp.getX()-r)*z), (int)((tp.getY()-r)*z), (int)((tp.getX()-r+f*r)*z), (int)((tp.getY()-r)*z));
                        g.drawLine((int)((tp.getX()-r)*z), (int)((tp.getY()-r)*z), (int)((tp.getX()-r)*z), (int)((tp.getY()-r+f*r)*z));
                        g.drawLine((int)((tp.getX()-r)*z), (int)((tp.getY()+r)*z), (int)((tp.getX()-r)*z), (int)((tp.getY()+r-f*r)*z));
                        g.drawLine((int)((tp.getX()-r)*z), (int)((tp.getY()+r)*z), (int)((tp.getX()-r+f*r)*z), (int)((tp.getY()+r)*z));
                        g.drawLine((int)((tp.getX()+r)*z), (int)((tp.getY()+r)*z), (int)((tp.getX()+r-f*r)*z), (int)((tp.getY()+r)*z));
                        g.drawLine((int)((tp.getX()+r)*z), (int)((tp.getY()+r)*z), (int)((tp.getX()+r)*z), (int)((tp.getY()+r-f*r)*z));
                        g.drawLine((int)((tp.getX()+r)*z), (int)((tp.getY()-r)*z), (int)((tp.getX()+r)*z), (int)((tp.getY()-r+f*r)*z));
                        g.drawLine((int)((tp.getX()+r)*z), (int)((tp.getY()-r)*z), (int)((tp.getX()+r-f*r)*z), (int)((tp.getY()-r)*z));
                    }
                    if (tp.isGoldStandard()) {
                        g.setColor(c_complement);
                        if (shape == tmarker.LABELS_SHAPE_CIRCLE) {
                            g.drawOval((int)((tp.getX()-r)*z), (int)((tp.getY()-r)*z), (int)(2*r*z), (int)(2*r*z));
                        } else if (shape == tmarker.LABELS_SHAPE_CROSS) {
                            g.drawLine((int)((tp.getX()-r)*z), (int)(tp.getY()*z)-1, (int)((tp.getX()+r)*z), (int)(tp.getY()*z)-1);
                            g.drawLine((int)(tp.getX()*z)-1, (int)((tp.getY()-r)*z), (int)(tp.getX()*z)-1, (int)((tp.getY()+r)*z));
                        } else if (shape == tmarker.LABELS_SHAPE_CROSS_THICK) {
                            g.drawLine((int)((tp.getX()-r)*z), (int)(tp.getY()*z)-1, (int)((tp.getX()+r)*z), (int)(tp.getY()*z)-1);
                            g.drawLine((int)((tp.getX()-r)*z), (int)(tp.getY()*z)+1, (int)((tp.getX()+r)*z), (int)(tp.getY()*z)+1);
                            g.drawLine((int)(tp.getX()*z)-1, (int)((tp.getY()-r)*z), (int)(tp.getX()*z)-1, (int)((tp.getY()+r)*z));
                            g.drawLine((int)(tp.getX()*z)+1, (int)((tp.getY()-r)*z), (int)(tp.getX()*z)+1, (int)((tp.getY()+r)*z)); 
                        } else {
                            double f=0.6;
                            g.drawLine((int)((tp.getX()-r)*z)-1, (int)((tp.getY()-r)*z)-1, (int)((tp.getX()-r+f*r)*z), (int)((tp.getY()-r)*z)-1);
                            g.drawLine((int)((tp.getX()-r)*z)-1, (int)((tp.getY()-r)*z)-1, (int)((tp.getX()-r)*z)-1, (int)((tp.getY()-r+f*r)*z)-1);
                            g.drawLine((int)((tp.getX()-r)*z)-1, (int)((tp.getY()+r)*z)-1, (int)((tp.getX()-r)*z)-1, (int)((tp.getY()+r-f*r)*z)-1);
                            g.drawLine((int)((tp.getX()-r)*z)-1, (int)((tp.getY()+r)*z)-1, (int)((tp.getX()-r+f*r)*z)-1, (int)((tp.getY()+r)*z)-1);
                            g.drawLine((int)((tp.getX()+r)*z)-1, (int)((tp.getY()+r)*z)-1, (int)((tp.getX()+r-f*r)*z)-1, (int)((tp.getY()+r)*z)-1);
                            g.drawLine((int)((tp.getX()+r)*z)-1, (int)((tp.getY()+r)*z)-1, (int)((tp.getX()+r)*z)-1, (int)((tp.getY()+r-f*r)*z)-1);
                            g.drawLine((int)((tp.getX()+r)*z)-1, (int)((tp.getY()-r)*z)-1, (int)((tp.getX()+r)*z)-1, (int)((tp.getY()-r+f*r)*z)-1);
                            g.drawLine((int)((tp.getX()+r)*z)-1, (int)((tp.getY()-r)*z)-1, (int)((tp.getX()+r-f*r)*z)-1, (int)((tp.getY()-r)*z)-1);
                        }
                        if (tp.getTMAspot().getCenter().isShowingTextLabels()) {
                            g.drawString((tp.getGoldStandard()==TMApoint.CONSENSUS?"cons":Byte.toString(tp.getGoldStandard())), (int)((tp.getX()-r)*z), (int)((tp.getY()-r)*z));
                        }
                    }
                    if (tp.isTrainingPoint(true) || tp.isTrainingPoint(false)) {
                        g.setColor(c_training);
                        g.fillOval((int)((tp.getX()-r/2)*z), (int)((tp.getY()-r/2)*z), (int)((r)*z), (int)((r)*z));
                    }
                }
            }
        }
    }
    
    @Override
    public void paintComponent(Graphics g) {
        ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        super.paintComponent(g);
        
        double z = getZoom();
        try {
            int x_min = (int)(ts.getCenter().getTMAViewContainer().getHorizontalScrollBar().getValue()/z);
            int y_min = (int)(ts.getCenter().getTMAViewContainer().getVerticalScrollBar().getValue()/z);
            int x_max = (int)(x_min+ts.getCenter().getTMAViewContainer().getViewport().getWidth()/z);
            int y_max = (int)(y_min+ts.getCenter().getTMAViewContainer().getViewport().getHeight()/z);
        
            // Setting the global AffineTransform of g to the scale and translation produces non-smooth display.
            // Alternatively, use the zoomfactor explicitely to draw the content.
            //AffineTransform at = AffineTransform.getScaleInstance(z, z);
            //at.translate(-x_min, -y_min);
            //((Graphics2D)g).setTransform(at);

            if (ts!=null) {
                for (Pluggable p: ts.getCenter().getPlugins()) {
                    try {
                        p.drawInformationPreNuclei(ts, g, z, x_min, y_min, x_max, y_max);
                    } catch (Error | Exception er) { 
                        Logger.getLogger(TMA_view_panel.class.getName()).log(java.util.logging.Level.WARNING, er.getMessage());
                    }
                }
                drawCellCounts(ts, g, z, x_min, y_min, x_max, y_max);
                drawAreas(ts, g, z, x_min, y_min, x_max, y_max);
                drawDensitySoft(ts, g, z, x_min, y_min, x_max, y_max);
                
                for (Pluggable p: ts.getCenter().getPlugins()) {
                    try {
                        p.drawInformationPostNuclei(ts, g, z, x_min, y_min, x_max, y_max);
                    } catch (Error | Exception er) { 
                        Logger.getLogger(TMA_view_panel.class.getName()).log(java.util.logging.Level.WARNING, er.getMessage());
                    }
                }
            }
        } catch (Exception e) {
        }
        
    }
    
    /**
     * Draws the including and excluding areas.
     * @param ts The TMAspot where the areas come from.
     * @param g The graphics on which is drawn.
     * @param z The scaling (zoom) factor of the image.
     * @param x_min The min x-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param y_min The min y-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param x_max The max x-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param y_max The max y-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     */
    public static void drawAreas(TMAspot ts, Graphics g, double z, int x_min, int y_min, int x_max, int y_max) {
        BasicStroke bs = new BasicStroke(3);
        ((Graphics2D)g).setStroke(bs);
        if (ts.getExcludingAreas()!=null && !ts.getExcludingAreas().isEmpty()) {
            g.setColor(Color.RED);
            for (Polygon p: ts.getExcludingAreas()) {
                int[] xs = new int[p.npoints];
                int[] ys = new int[p.npoints];
                for (int j=0; j<xs.length; j++) {
                    xs[j] = (int) (z*(double) (p.xpoints[j]));
                    ys[j] = (int) (z*(double) (p.ypoints[j]));
                }
                g.drawPolygon(xs, ys, xs.length);
            }
        }
        
        if (ts.getIncludingAreas()!=null && !ts.getIncludingAreas().isEmpty()) {
            g.setColor(Color.GREEN);
            for (Polygon p: ts.getIncludingAreas()) {
                int[] xs = new int[p.npoints];
                int[] ys = new int[p.npoints];
                for (int j=0; j<xs.length; j++) {
                    xs[j] = (int) (z*(double) (p.xpoints[j]));
                    ys[j] = (int) (z*(double) (p.ypoints[j]));
                }
                g.drawPolygon(xs, ys, xs.length);
            }
        }
        
        if (!ts.getCenter().getTMAView().getRecentPolyline_x().isEmpty()) {
            g.setColor(Color.YELLOW);
            int[] xs = new int[ts.getCenter().getTMAView().getRecentPolyline_x().size()];
            int[] ys = new int[ts.getCenter().getTMAView().getRecentPolyline_x().size()];
                for (int i=0; i<ts.getCenter().getTMAView().getRecentPolyline_x().size(); i++) {
                    xs[i] = (int) (z*(double) (ts.getCenter().getTMAView().getRecentPolyline_x().get(i)));
                    ys[i] = (int) (z*(double) (ts.getCenter().getTMAView().getRecentPolyline_y().get(i)));
                }
                g.drawPolyline(xs, ys, xs.length);
        }
    }
    
    /**
     * Draws the soft density heatmap as overlay.
     * @param ts The TMAspot where the TMApoints come from.
     * @param g The graphics on which is drawn.
     * @param z The scaling (zoom) factor of the image.
     * @param x_min The min x-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param y_min The min y-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param x_max The max x-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     * @param y_max The max y-coord which is visible in the zoomable image pane, relative to the original image coordinates (i.e. independent from the zoom).
     */
    public static void drawDensitySoft(TMAspot ts, Graphics g, double z, int x_min, int y_min, int x_max, int y_max) {
        if (ts.getCenter().isShowingCellDensitySoft()) {
            List<TMApoint> tps = ts.getPoints();
            int width = 10*Math.max(1, ts.getParam_r());
            for (TMApoint tp: tps) {
                // if the point is in the viewport display it.
                if (tp.x >= x_min && tp.y >= y_min && tp.x < x_max && tp.y < y_max) {
                    Point2D center = new Point2D.Float((int) (z*(double) (tp.x)), (int) (z*(double) (tp.y)));
                    float[] dist = {0.0f, 1.0f};
                    Color[] colors = {new Color(0, 0, 0, 60), new Color(0, 0, 0, 0)};
                    RadialGradientPaint p =  new RadialGradientPaint(center, (float) (z*width/2), dist, colors);
                    ((Graphics2D)g).setPaint(p);
                    ((Graphics2D)g).fillOval((int) (z*(double) (tp.x-width/2)), (int) (z*(double) (tp.y-width/2)), (int) (z*(double) (width)), (int) (z*(double) (width)));
                }
            }
        }
    }
    
    /**
     * returns the original image width.
     * @return The image width.
     */
    @Override
    public int getImageWidth() {
        return Image_Width;
    }
    
    /**
     * returns the original image height.
     * @return The image height.
     */
    @Override
    public int getImageHeight() {
        return Image_Height;
    }

    /**
     * Returns the recent drawn polyline. Important for the drawing of including or excluding areas.
     * @return The recently drawn polyline x-coords.
     */
    @Override
    public List<Integer> getRecentPolyline_x() {
        return RECENT_POLYLINE_X;
    }
    
    /**
     * Returns the recent drawn polyline. Important for the drawing of including or excluding areas.
     * @return The recently drawn polyline y-coords.
     */
    @Override
    public List<Integer> getRecentPolyline_y() {
        return RECENT_POLYLINE_Y;
    }

    /**
     * Indicates that the user does not want to draw an area anymore. The recent polyline is cleared.
     */
    @Override
    public void reliefRecentPolyLine() {
        RECENT_POLYLINE_X.clear();
        RECENT_POLYLINE_Y.clear();
        repaint();
    }
    
    /**
     * Enables / disables the popup menu.
     * @param b If true, the popup menu is enabled. Otherwise disabled.
     */
    @Override
    public void enablePopupMenu(boolean b) {
        if (b) {
            setComponentPopupMenu(jPopupMenu1);
        } else {
            setComponentPopupMenu(null);
        }
    }

    /**
     * Returns the currently displayed TMAspot.
     * @return The currently displayed TMAspot. Null if there is none.
     */
    @Override
    public TMAspot getTMAspot() {
        return ts;
    }
    
    /**
     * Sets the coordinates x, y of the image into the center of the current view. After calling, the
     * user sees point x, y of the original image in the middle of the TMA view screen, at the same zoom level as before.
     * If x, y is too close at the border, the image is scrolled to the nearest possible position.
     * @param x The x coordinate as original image coordinate.
     * @param y The y coordinate as original image coordinate.
     */
    @Override
    public void jumpToVisibleLocus(int x, int y) {
        JScrollPane jsp = t.getTMAViewContainer();
        Rectangle r = jsp.getViewport().getViewRect();
        Point Pold = new Point(r.x + r.width/2, r.y + r.height/2);
        int x_upperleft = (int)(x)-(int)(Pold.x/getZoom());
        int y_upperleft = (int)(y)-(int)(Pold.y/getZoom());
        r.setLocation((int)(x_upperleft*getZoom()), (int)(y_upperleft*getZoom()));
        jsp.getViewport().scrollRectToVisible(r);
        
        t.showTMAspotLocalZoom(x,y);
        t.showTMAspotLocalZoomOnPreview(x,y);
    }
    
}